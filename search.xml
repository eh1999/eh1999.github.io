<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot基础</title>
      <link href="/2020/07/03/SpringBoot%E4%B9%8BSpringBoot%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/07/03/SpringBoot%E4%B9%8BSpringBoot%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot项目结构"><a href="#SpringBoot项目结构" class="headerlink" title="SpringBoot项目结构"></a>SpringBoot项目结构</h1><ol><li><font color=red>src/main/java</font>:入口（启动）类及程序的开发目录。在这个目录下进行业务开发、创建实体层、控制器层、数据连接层等</li><li><font color=red>src/main/resources</font>:资源文件目录，主要用于存放静态文件和配置文件。<ul><li><font color=red>static</font>:用于存放静态资源，如层叠样式表 CSS文件（Cascading Style Sheets）文件、JavaScript文件、图片等</li><li><font color=red>templates</font>:用于存放模板文件</li><li><font color=red>application.properties</font>:用于配置项目运行所需的配置数据。如果用YAML方式管理配置，则YAML文件也放在这个目录中</li></ul></li><li><font color=red>src/test/java</font>:测试程序所在的目录</li></ol><h1 id="SpringBoot依赖模块"><a href="#SpringBoot依赖模块" class="headerlink" title="SpringBoot依赖模块"></a>SpringBoot依赖模块</h1><ul><li>核心模块<font color=red>spring-boot-starter</font>:用于支持自动配置、日志和YAML</li><li>测试模块<font color=red>spring-boot-starter-test</font>:包括JUnit、Hamcrest和Mockito，用于测试</li></ul>  <h1 id="SpringBoot入口类"><a href="#SpringBoot入口类" class="headerlink" title="SpringBoot入口类"></a>SpringBoot入口类</h1><p>&#8194;&#8194;&#8194;&#8194;在创建SpringBoot项目时，会自动创建一个用于启动的、名为“项目名+Application”的入口类，它是项目的启动入口。在IDEA中打开入口类后，可以单击类或“main”方法左侧的三角形按钮，通过弹出的选项来运行或调试SpringBoot应用程序。<br>&#8194;&#8194;&#8194;&#8194;加上注解<font color=red>@SpringBootApplication</font>，以标注这是SpringBoot项目的入口类。</p><h1 id="SpringBoot的自动配置"><a href="#SpringBoot的自动配置" class="headerlink" title="SpringBoot的自动配置"></a>SpringBoot的自动配置</h1><p>&#8194;&#8194;&#8194;&#8194;SpringBoot会根据配置的依赖信息进行自动配置，从而减轻开发者搭建环境和配置的负担。如果在项目中依赖了<font color=red>spring-boot-starter-web</font>，则SpringBoot会自动配置Web环境（配置Tomcat、WebMVC、Validator、JSON等）。<br>&#8194;&#8194;&#8194;&#8194;SpringBoot自动配置是通过注解<font color=red>@EnableAutoConfiguration</font>来实现的，具有非侵入性。<br>&#8194;&#8194;&#8194;&#8194;如果不需要某些自动配置，则可以通过注解<font color=red>@EnableAutoConfiguration</font>的“<font color=red>exclude</font>或<font color=red>excludeName</font>”属性来指定，或在配置文件（<font color=red>application.properties</font>或<font color=red>application.yml</font>）中指定“<font color=red>spring.autoconfigure.exclude</font>”的值。</p><h1 id="SpringBoot热部署"><a href="#SpringBoot热部署" class="headerlink" title="SpringBoot热部署"></a>SpringBoot热部署</h1><p>&#8194;&#8194;&#8194;&#8194;SpringBoot热部署是为了更好的支持调试，在项目进行修改后不需要耗费时间重启，在应用程序正常运行的情况下即可实时生效，以节约时间和操作。要实现热部署，则需要添加下方的热部署的依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><h1 id="SpringBoot的常用注解"><a href="#SpringBoot的常用注解" class="headerlink" title="SpringBoot的常用注解"></a>SpringBoot的常用注解</br></h1><p><font size=4>什么是注解式编程</font><br>&#8194;&#8194;&#8194;&#8194;注解（annotations）用来定义一个类、属性或一些方法、以便程序能被编译处理。它相当于一个说明文件，告诉应用程序某个被注解的类或属性是什么，要怎么处理。注解可以用于标注包、类、方法和变量等。</li></p><center><font size=4>系统注解</font></center><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Override</td><td>用于修饰方法，表示此方法重写了父类方法</td></tr><tr><td>@Deprecated</td><td>用于修饰方法，表示此方法已经过时。经常在版本升级后会遇到</td></tr><tr><td>@SuppressWarnnings</td><td>告诉编译器忽视某类编译警告</td></tr></tbody></table><p>下面重点介绍一下<font color=red>@SuppressWarnnings</font>注解。它有以下几种属性。</p><ul><li><font color=red>unchecked</font>:未检查的转化。</li><li><font color=red>unused</font>:未使用的变量。</li><li><font color=red>resource</font>:泛型，即未指定类型。</li><li><font color=red>path</font>:在类中的路径。原文件路径中有不存在的路径。</li><li><font color=red>deprecation</font>:使用了某些不赞成使用的类和方法</li><li><font color=red>fallthrough</font>:switch语句执行到底，不会遇到break关键字。</li><li><font color=red>serial</font>:实现了Serializable，但未定义serialVersionUID。</li><li><font color=red>rawtypes</font>:没有传递带有泛型的参数。</li><li><font color=red>all</font>:代表全部类型的警告。</li></ul><center><font size=4>使用在类名上的注解</font></center><table><thead><tr><th>注解</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@RestController</td><td>类名上</td><td>作用相当于@ResponseBody加@Controller</td></tr><tr><td>@Controller</td><td>类名上</td><td>声明此类是一个SpringMVC Controller对象</td></tr><tr><td>@Service</td><td>类名上</td><td>声明一个业务处理类（实现非接口类）</td></tr><tr><td>@Repository</td><td>类名上</td><td>声明数据库访问类（实现非接口类）</td></tr><tr><td>@Component</td><td>类名上</td><td>代表其是Spring管理类，常用在无法用@Service、@Repository描述的Spring管理的类上，相当于通用的注解</td></tr><tr><td>@Configuration</td><td>类名上</td><td>声明此类是一个配置类，常与@Bean配合使用</td></tr><tr><td>@Resource</td><td>类名上、属性或构造函数参数上</td><td>默认按byName自动注入</td></tr><tr><td>@Autowired</td><td>类名上、属性或构造函数参数上</td><td>默认按byType自动注入</td></tr><tr><td>@RequestMapping</td><td>类名或方法上</td><td>如果用在类上，则表示所有响应请求的方法都是以该地址作为父路径的</td></tr><tr><td>@Transactional</td><td>类名或方法上</td><td>用于处理事务</td></tr><tr><td>@Qualifier</td><td>类名或属性上</td><td>为Bean指定名称，随后再通过名字引用Bean</td></tr></tbody></table><p>下面进一步讲解各个注解的知识点和用法</p><ol><font size=4>1</font>.<font color=red>@RestController</font></br>&#8194;&#8194;&#8194;&#8194;它用于返回JSON（JavaScript Object Notation，JS对象简谱）、XML（eXtensible Markup Language）等数据，但不能返回HTML（HyperText Markup Language）页面。相当于注解@ResponseBody和注解@Controller合在一起的作用。</br><font size=4>2</font>.<font color=red>@Controller</font></br>&#8194;&#8194;&#8194;&#8194;它用于标注控制器曾，在MVC开发模式中代表C（控制器）</br>&#8194;&#8194;&#8194;&#8194;@Controller主要用于构建MVC模式的程序</br><font size=4>3</font>.<font color=red>@Service</font></br>&#8194;&#8194;&#8194;&#8194;它用于声明一个业务处理类（实现非接口类），用于标注服务层，处理业务逻辑。</br><font size=4>4</font>.<font color=red>@Repository</font></br>&#8194;&#8194;&#8194;&#8194;它用于标注数据访问层</br><font size=4>5</font>.<font color=red>@Component</font></br>&#8194;&#8194;&#8194;&#8194;它用于把普通POJO（Plain Ordinary Java Objects，简单的Java对象）实例化到Spring容器中。当类不属于注解@Controller和@Service等时，就可以使用注解@Component来标注这个类。它可配合CommandLineRunner使用，以便在程序启动后执行一些基础任务。</br><font size=4>6</font>.<font color=red>@Configuration</font></br>&#8194;&#8194;&#8194;&#8194;他用于标注配置类，并且可以由Spring容器自动处理。它作为Bean的载体，用来指示一个类声明、一个或多个@Bean方法，在运行时为这些Bean生成BeanDefinition和服务请求</br><font size=4>7</font>.<font color=red>@Resource</font></br>&#8194;&#8194;&#8194;&#8194;@Autowired与@Resource都可以用来装配Bean，也都可以写在字段上或Setter方法上。</br><font size=4>8</font>.<font color=red>@Autowired</font></br>&#8194;&#8194;&#8194;&#8194;它表示被修饰的类需要注入对象。Spring会扫描所有被@Autowired标注的类，然后根据类型在IoC容器中找到匹配的类进行注入。被@Autowired注解后的类不需要再导入文件。</br><font size=4>9</font>.<font color=red>@RequestMapping</font></br>&#8194;&#8194;&#8194;&#8194;它用来请求地址映射，用在类或方法上。如果用在类上，则表示类中的所有响应请求的方法都是以该地址作为父路径的。该注解有6个属性。</br><ul>    <li><font color=red>Params</font>:指定Request中必须包含某些参数值，才让该方法处理。</li>    <li><font color=red>Headers</font>:指定Request中必须包含某些指定的header值，才能让该方法处理。</li>    <li><font color=red>Value</font>:指定请求的实际地址，指定的地址可以是URI Template模式。</li>    <li><font color=red>Method</font>:指定请求的Method类型，如GET、POST、PUT、DELETE等。</li>    <li><font color=red>Consumes</font>:指定处理请求的提交内容类型Content-Type，如“application/json,text/html”。</li>    <li><font color=red>Produces</font>:指定返回的内容类型。只有当Request请求头中的Accept类型中包含该指定类型时才返回。</li></ul><font size=4>10</font>.<font color=red>@Transactional</font></br>&#8194;&#8194;&#8194;&#8194;它可以用在接口、接口方法、类及类方法上。</br>&#8194;&#8194;&#8194;&#8194;但Spring不建议在接口或者接口方法上使用该注解，因为该注解只有在使用基于接口的代理时才会生效。如果异常被捕获（try{}catch{}）了，则事务就不回滚了。如果想让事务回滚，则必须再往外抛出异常（try{}catch{throw Exception}）。</br><font size=4>11</font>.<font color=red>@Qualifier</font></br>&#8194;&#8194;&#8194;&#8194;它的意思是“合格者”，用于标注哪一个实现类才是需要注入的。需要注意的是，@Qualifier的参数名称为被注入的类中的注解@Service标注的名称。</br>&#8194;&#8194;&#8194;&#8194;@Qualifier常和@Autowired一起使用。而@Resource和它不同，@Resource自带name属性。</br></ol><center><font size=4>使用在方法上的主要注解</font></center><table><thead><tr><th>注解</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@RequestBody</td><td>方法参数前</td><td>常用来处理application/json、application/xml等Content-Type类型的数据，意味着HTTP消息是JSON/XML格式，需将其转化为指定类型参数</td></tr><tr><td>@PathVariable</td><td>方法参数前</td><td>将URL获取的参数映射到方法参数上</td></tr><tr><td>@Bean</td><td>方法上</td><td>声明该方法的返回结果是一个由Spring容器管理的Bean</td></tr><tr><td>@ResponsetBody</td><td>方法上</td><td>通过适当的HttpMessageConverter将控制器中方法返回的对象转换为指定格式（JSON/XML）后，写入Response对象的body数据区</td></tr></tbody></table><ol><font size=4>1</font>.<font color=red>@RequestBody</font></br>&#8194;&#8194;&#8194;&#8194;它常用来处理JSON/XML格式的数据。通过@RequestBody可以将请求体中的（JSON/XML）字符串绑定到相应的Bean上，也可以将其分别绑定到对应的字符串上。<font size=4>2</font>.<font color=red>@PathVariable</font></br>&#8194;&#8194;&#8194;&#8194;用于获取路径中的参数</br><font size=4>3</font>.<font color=red>@Bean</font></br>&#8194;&#8194;&#8194;&#8194;它代表产生一个Bean，并交给Spring管理。用于封装数据，一般有Setter、Getter方法。在MVC模型中，对应的是M（模型）。</br><font size=4>4</font>.<font color=red>@ResponsetBody</font></br>&#8194;&#8194;&#8194;&#8194;它的作用是通过转换器将控制器方法返回的对象转换为指定的格式，然后写入Response对象的body区。它常用来返回JSON/XML格式的数据。通过@RequestBody可以将请求体中的（JSON/XML）字符串绑定到相应的Bean上，也可以将其分别绑定到对应的字符串上。</br>&#8194;&#8194;&#8194;&#8194;使用此注解后，数据直接写入输入流中，不需要进行视图渲染。</br></ol><center><font size=4>其他常用注解</font></center>。<table><thead><tr><th>注解</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@EnableAutoConfiguration</td><td>入口类/类名上</td><td>用来提供自动配置</td></tr><tr><td>@SpringBootApplication</td><td>入口类/类名上</td><td>用来启动入口类Application</td></tr><tr><td>@EnableScheduling</td><td>入口类/类名上</td><td>用来开启计划任务。Spring通过@Scheduled支持多种类型的计划任务，包含cron、fixDelay、fixRate等</td></tr><tr><td>@EnableAsync</td><td>入口类/类名上</td><td>用来开启异步注解功能</td></tr><tr><td>@ComponentScan</td><td>入口类/类名上</td><td>用来扫描组件，可自动发现和装配一些Bean。它根据定义的扫描路径，把符合扫描规则的类装配到Spring容器中，告诉Spring那个包（package）的类会被Spring自动扫描并且装入IoC容器。它对应XML配置中的元素。可以通过basePackages等属性来细粒度地定制自动扫描的范围，默认会从声明@ComponentScan所在类的包进行扫描</td></tr><tr><td>@Aspec</td><td>入口类/类名上</td><td>标注切面，可以用来配置事务、日志、权限验证，在用户请求时做一些处理等</td></tr><tr><td>@ControllerAdvice</td><td>类名上</td><td>包含@ComponentScan，可以被扫描到。统一处理异常</td></tr><tr><td>@ExceptionHandler</td><td>方法上</td><td>用在方法上，表示遇到异常就执行该方法</td></tr><tr><td>@Value</td><td>属性上</td><td>用于获取配置文件中的值</td></tr></tbody></table><h1 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h1><p>&#8194;&#8194;&#8194;&#8194;SpringBoot支持使用Properties和YAML两种配置方式。两者功能类似，都能完成SpringBoot的配置，但是<font color=red>Properties的优先级要高于YAML</font>。<br>&#8194;&#8194;&#8194;&#8194;YAML文件的好处是——它采用的是树状结构，一目了然。但是，使用YAML配置方式时要注意以下几点。</p><ul><li>原来以“.”分隔的key会变成树状结构</li><li>在key后的冒号后一定要跟一个空格</li><li>如果把原有的application.properties删除，则建议执行以下“<font color=red>maven -X clean install</font>”命令</li><li>YAML格式不支持用注解<font color=red>@PropertySource</font>导入配置</li></ul><h1 id="SpringBoot的Starter"><a href="#SpringBoot的Starter" class="headerlink" title="SpringBoot的Starter"></a>SpringBoot的Starter</br></h1><p><font size=4>了解Starter</font><br>&#8194;&#8194;&#8194;&#8194;SpringBoot为了简化配置，提供了非常多的Starter。它先打包好与常用模块相关的所有JAR包，并完成自动配置，然后组装成Starter（如把Web相关的SpringMVC、容器等打包好后组装成spring-boot-starter-web）。这使得在开发业务代码是不需要过多关注框架的配置，只需关注逻辑即可。</p><center><font size=4>常用的Starter</font></center><table><thead><tr><th>Starter</th><th>说明</th></tr></thead><tbody><tr><td>spring-boot-stater-web</td><td>用于构建Web。包含RESTful风格框架、SpringMVC和默认的嵌入式容器Tomcat</td></tr><tr><td>spring-boot-stater-test</td><td>用于测试</td></tr><tr><td>spring-boot-stater-data-jpa</td><td>带有Hibernate的SpringDataJPA</td></tr><tr><td>spring-boot-stater-jdbc</td><td>传统的JDBC。轻量级应用可以使用，学习成本低，但最好使用JPA或Mybatis</td></tr><tr><td>spring-boot-stater-thymeleaf</td><td>支持Thymeleaf</td></tr><tr><td>spring-boot-stater-mail</td><td>支持JavaMail、SpringMail发送邮件</td></tr><tr><td>spring-boot-stater-integration</td><td>Spring框架创建的一个API，面向企业应用集成（EAI）</td></tr><tr><td>spring-boot-stater-mobile</td><td>SpringMVC的扩展，用来简化手机上的Web应用程序开发</td></tr><tr><td>spring-boot-stater-data-redis</td><td>通过SpringDataRedis、RedisClient使用Redis</td></tr><tr><td>spring-boot-stater-validation</td><td>BeanValidation是一个数据验证的规范，HibernateValidator是一个数据验证框架</td></tr><tr><td>spring-boot-stater-websocket</td><td>相对于非持久的协议HTTP，Websocket是一个持久化的协议</td></tr><tr><td>spring-boot-stater-web-services</td><td>SOAPWebServices</td></tr><tr><td>spring-boot-stater-hateoas</td><td>为服务添加HATEOAS功能</td></tr><tr><td>spring-boot-stater-security</td><td>用SpringSecurity进行身份验证和授权</td></tr><tr><td>spring-boot-stater-data-rest</td><td>用SpringDateREST公布简单的REST服务</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
